<body bgcolor=black>

<script>
const NQ = 6;
const NSPHERES = 4;
</script>

<!-- <script src=fragmentShader.js type="module"></script> -->
<script src=matrix.js type="module"></script>
<script src=quadric.js type="module"></script>

<center>
<canvas id='canvas1' width=800 height=800></canvas>

<script type="module">
    import { 
        translation,
        rotationX,
        rotationY,
        rotationZ,
        scale,
        multiply,
        transpose,
        value,
        toString,
        identity
    } from './matrix.js';
    import { 
        sphere,
        xParaboloid,
        yParaboloid,
        zParaboloid,
        xSlab,
        ySlab,
        zSlab,
        xCylinder,
        yCylinder,
        zCylinder,
        everywhere
    } from './quadric.js';

    // import _fragmentShader from './fragmentShader.js';
    import _fragmentShader from './otherFrag2.js';


let vertexSize = 3;
let vertexShader = `
    attribute vec3 aPos;
    varying   vec3 vPos;
    void main() {
        gl_Position = vec4(aPos, 1.0);
        vPos = aPos;
    }
`;

let fragmentShader = _fragmentShader(NQ);

// INITIALIZE GPU PROGRAM

let start_gl = (canvas, meshData, vertexSize, vertexShader, fragmentShader) => {
    let gl = canvas.getContext("webgl");
    let program = gl.createProgram();
    gl.program = program;
    let addshader = (type, src) => {
        let shader = gl.createShader(type);
        gl.shaderSource(shader, src);
        gl.compileShader(shader);
        if (! gl.getShaderParameter(shader, gl.COMPILE_STATUS))
            throw "Cannot compile shader:\n\n" + gl.getShaderInfoLog(shader);
        gl.attachShader(program, shader);
    };
    addshader(gl.VERTEX_SHADER  , vertexShader  );
    addshader(gl.FRAGMENT_SHADER, fragmentShader);
    gl.linkProgram(program);
    if (! gl.getProgramParameter(program, gl.LINK_STATUS))
        throw "Could not link the shader program!";
    gl.useProgram(program);
    gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);
    let vertexAttribute = (name, size, position) => {
        let attr = gl.getAttribLocation(program, name);
        gl.enableVertexAttribArray(attr);
        gl.vertexAttribPointer(attr, size, gl.FLOAT, false, vertexSize * 4, position * 4);
    }
    vertexAttribute('aPos', 3, 0);
    return gl;
}

// LOGIC TO TRACK THE CURSOR

let r = canvas1.getBoundingClientRect(), cursor = [0,0,0];
let setCursor = (e, z) => cursor = [ (e.clientX - r.left) / canvas1.width * 2 - 1,
                                        1 - (e.clientY - r.top) / canvas1.height * 2,
                                        z !== undefined ? z : cursor[2] ];
canvas1.onmousedown = e => setCursor(e, 1);
canvas1.onmousemove = e => setCursor(e,  );
canvas1.onmouseup   = e => setCursor(e, 0);

// TRIANGLE DATA (IN THIS CASE, ONE SQUARE)

let meshData = [
    { type: 1, mesh: new Float32Array([ -1,1,0, 1,1,0, -1,-1,0, 1,-1,0 ]) },
];

// DEFINE A MATRIX INVERSE FUNCTION

let matrixInverse = src => {
    let dst = [], det = 0, cofactor = (c, r) => {
        let s = (i, j) => src[c+i & 3 | (r+j & 3) << 2];
        return (c+r & 1 ? -1 : 1) * ( (s(1,1) * (s(2,2) * s(3,3) - s(3,2) * s(2,3)))
                                    - (s(2,1) * (s(1,2) * s(3,3) - s(3,2) * s(1,3)))
                                    + (s(3,1) * (s(1,2) * s(2,3) - s(2,2) * s(1,3))) );
    }
    for (let n = 0 ; n < 16 ; n++) dst.push(cofactor(n >> 2, n & 3));
    for (let n = 0 ; n <  4 ; n++) det += src[n] * dst[n << 2];
    for (let n = 0 ; n < 16 ; n++) dst[n] /= det;
    return dst;
}

setTimeout(() => {
    let gl = start_gl(canvas1, meshData, vertexSize, vertexShader, fragmentShader);

    // FIND LOCATIONS IN GPU PROGRAM OF UNIFORM VARIABLES

    let uFL       = gl.getUniformLocation(gl.program, "uFL"    );
    let uTime     = gl.getUniformLocation(gl.program, "uTime"  );
    let uCursor   = gl.getUniformLocation(gl.program, "uCursor"); 
    let uL        = gl.getUniformLocation(gl.program, "uL"     ); 
    let uA        = gl.getUniformLocation(gl.program, "uA"     ); 
    let uB        = gl.getUniformLocation(gl.program, "uB"     ); 
    let uC        = gl.getUniformLocation(gl.program, "uC"     ); 

    const u_cameraPositionLocation = gl.getUniformLocation(gl.program, 'u_cameraPosition');
    const u_cameraTargetLocation = gl.getUniformLocation(gl.program, 'u_cameraTarget');
    const u_fovLocation = gl.getUniformLocation(gl.program, 'u_fov');
    const u_aspectRatioLocation = gl.getUniformLocation(gl.program, 'u_aspectRatio');
    const u_timeLocation = gl.getUniformLocation(gl.program, 'u_time');

    const u_quadricCylinderLocation = gl.getUniformLocation(gl.program, 'u_quadricCylinder');
    const u_quadricSlabLocation = gl.getUniformLocation(gl.program, 'u_quadricSlab');
    const u_quadricEverywhereLocation = gl.getUniformLocation(gl.program, 'u_quadricEverywhere');

    // Set the camera position and target to avoid rotating inside the cylinder
    const cameraPosition = [0, 0, 15]; // Keep the camera further away
    const cameraTarget = [0, 0, 0];
    gl.uniform3fv(u_cameraPositionLocation, cameraPosition);
    gl.uniform3fv(u_cameraTargetLocation, cameraTarget);

    // Set the field of view and aspect ratio
    const fov = 60.0;
    const aspectRatio = canvas1.width / canvas1.height;
    gl.uniform1f(u_fovLocation, fov);
    gl.uniform1f(u_aspectRatioLocation, aspectRatio);

    const R = 1.0;
    const quadricCylinder = new Float32Array([
        0, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, -R * R
    ]);

    // Set the quadric matrix for the xSlab
    const quadricSlab = new Float32Array([
        1, 0, 0, 0,
        0, 0, 0, 0,
        0, 0, 0, 0,
        0, 0, 0, -1
    ]);


    // Set the quadric matrix for the everywhere matrix (everywhere is unchanged)
    const quadricEverywhere = new Float32Array([
        0, 0, 0, 0,
        0, 0, 0, 0,
        0, 0, 0, 0,
        0, 0, 0, -1
    ]);

    // Set uniforms
    gl.uniformMatrix4fv(u_quadricCylinderLocation, false, quadricCylinder);
    gl.uniformMatrix4fv(u_quadricSlabLocation, false, quadricSlab);
    gl.uniformMatrix4fv(u_quadricEverywhereLocation, false, quadricEverywhere);

    // ANIMATE AND RENDER EACH ANIMATION FRAME

    let startTime = Date.now() / 1000;
    setInterval(() => {
        
        // SET UNIFORM VARIABLES

        let time = Date.now() / 1000 - startTime;

        gl.uniform1f(u_timeLocation, time);

        gl.uniform1f(uTime, time);
        gl.uniform3fv(uCursor, cursor);
        gl.uniform3fv(uL, [-.57,-.57,-.57, .57,.57,.57]);
        gl.uniform1f(uFL, 3);
        
        // DEFINE ANIMATION MATRICES

        let s1 = Math.sin(time);
        let s2 = Math.sin(2 * time);

/**************************************************************************

        In matrix.js I have implemented these functions:

            translation(x,y,z)
            rotationX(t)
            rotationY(t)
            rotationZ(t)
            scale(x,y,z)
            multiply(a,b)
            transpose(m)

        In quadric.js I have defined these 4x4 matrices:

            sphere
            xParaboloid
            yParaboloid
            zParaboloid
            xSlab
            ySlab
            zSlab
            xCylinder
            yCylinder
            zCylinder
            everywhere

**************************************************************************/

        let A = multiply(translation(-4,-3.5,-20),
                        multiply(rotationY(s2),
                                multiply(rotationZ(s1),
                        scale(1.5,1,1.5))));

        let B = multiply(translation(0,-3.5,-20),
                        multiply(rotationY(s2),
                                multiply(rotationZ(s1),
                        scale(1,1,1))));

        let C = multiply(translation(4,-3.5,-20),
                        multiply(rotationY(s2),
                                multiply(rotationZ(s1),
                        scale(.7,1.4,1))));

        let D = multiply(translation(-2,0,-20),
                        multiply(rotationY(s2),
                                multiply(rotationZ(s1),
                            scale(.5,1,1))));

        let E = multiply(translation(2,0,-20),
                        multiply(rotationY(s2),
                                multiply(rotationZ(s1),
                        scale(1,.7,1.3))));
/*
        let E = multiply(translation(2,0,-20),
                        multiply(scale(1,.5,1.5),
                                multiply(rotationZ(s1),
                        rotationY(s2))));
*/
        let F = multiply(translation(0,3.5,-20),
                        multiply(rotationY(s2),
                                rotationZ(s1)));

        // ANIMATE ALL QUADRICS FOR THIS FRAME

        // had to write this function to convert the flat array to a 4x4 matrix
        let arrayToMatrix = (arr) => {
            let matrix = [];
            for (let i = 0; i < 4; i++) {
            matrix.push([arr[i], arr[i + 4], arr[i + 8], arr[i + 12]]);
            }
            return matrix;
        };
        // had to modify this function because I'm not using flat arrays
        let transform = (Q,M) => {
            let MI = arrayToMatrix(matrixInverse(M.flat(Infinity)));
            return multiply(transpose(MI), multiply(Q, MI));
        }

        let MA = [], MB = [], MC = [];

        let addShape = (M,a,b,c) => {
            MA.push(transform(a, M));
            MB.push(transform(b===undefined ? everywhere : b, M));
            MC.push(transform(c===undefined ? everywhere : c, M));
        }

        addShape(A, transform(sphere, translation(0,-.35,0)),
                    transform(sphere, translation(0, .35,0)));
        addShape(B, xCylinder, yCylinder, zCylinder);
        //addShape(C, sphere, transform(xSlab, scale(.5,.5,.5)));
        addShape(C, sphere);
        addShape(D, xCylinder, xSlab);
        addShape(E, xSlab, ySlab, zSlab);
        addShape(F, yParaboloid, ySlab);

/*
        let C1 = translation(0, 0, -20);
        addShape(C1, sphere);

        let C2 = translation(5 * Math.sin(time), 0, -20 + 5 * Math.cos(time));
        addShape(C2, sphere);
*/

        // SEND QUADRIC DATA TO THE FRAGMENT SHADER

        // had to make it flatten my nested arrays w/ Infinity
        gl.uniformMatrix4fv(uA, false, new Float32Array(MA.flat(Infinity)));
        gl.uniformMatrix4fv(uB, false, new Float32Array(MB.flat(Infinity)));
        gl.uniformMatrix4fv(uC, false, new Float32Array(MC.flat(Infinity)));

/**************************************************************************

    // The relevant code in fragmentShader.js looks like this:

    uniform mat4 uA[`+NQ+`], uB[`+NQ+`], uC[`+NQ+`];

    // In the fragment shader main(), these values can be access like this:

            for (int i = 0 ; i < `+NQ+` ; i++) {
        mat4 Q = uA[i];

        float a = Q[0].x;
        float j = Q[3].w;
        Q[1].y
        Q[2].z
        Q[3].x
        ...
        }

**************************************************************************/

        // RENDER THE FRAME

        for (let n = 0 ; n < meshData.length ; n++) {
            let mesh = meshData[n].mesh;
            gl.bufferData(gl.ARRAY_BUFFER, mesh, gl.STATIC_DRAW);
            gl.drawArrays(meshData[n].type ? gl.TRIANGLE_STRIP : gl.TRIANGLES, 0, mesh.length / vertexSize);
        }
    }, 30);
}, 100);
</script>

    