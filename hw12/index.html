<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Page Title</title>
  </head>
  <body>
    <div style="margin: 10px;">
      <form id="uploadPDB">
        <input type="file" name="file" id="file">
        <input type="submit" value="upload">
      </form>
      
      <div style="margin-top: 10px;">
        Or select an example:
        <select id="examplePDB">
          <option value="">Select a PDB</option>
          <option value="zar1">ZAR1</option>
          <option value="rps2">RPS2</option>
        </select>
      </div>
    </div>
    <canvas id="canvas" width=900 height=700></canvas>
    <script src="pdb.js" type="module"></script>
    <script src="lib.js"></script>
    <script src="splines.js" type="module"></script>
    <script type="module">
      import { PDB } from './pdb.js';
      import { CatmullRom } from './splines.js';

      let prebuiltSplines = [];
      const glContext = startGL(canvas);
      trackMouse(canvas);

      // Initial test spline
      const testPoints = [-2.0, -2.0, 0.0, 0.0, 2.0, 0.0, 2.0, -2.0, 0.0];
      prebuiltSplines.push(Spline(glContext, testPoints));

      async function processPDBFile(file) {
        try {
          window.pdb = await PDB.fromFile(file);
          prebuiltSplines = [];
          
          const normalizedChains = pdb.normalizeCoordinates(window.pdb.chain_backbone_coordinates);
          
          normalizedChains.forEach((chain, i) => {
            const points = chain.coordinates.flatMap(coord => [coord.x, coord.y, coord.z]);
            const sampledPoints = [];
            for(let j = 0; j < points.length; j += 9) {
              sampledPoints.push(points[j], points[j+1], points[j+2]);
            }
            
            if (sampledPoints.length >= 12) {
              const splinePoints = CatmullRom(sampledPoints, 3);
              prebuiltSplines.push(Spline(glContext, splinePoints));
            }
          });

          canvas.zoom = 0.5;
          canvas.rx = 0;
          canvas.ry = 0;
        } catch (error) {
          console.error("Error processing PDB file:", error);
        }
      }

      // Handle file upload
      document.getElementById('uploadPDB').addEventListener('submit', async function(e) {
        e.preventDefault();
        let file = document.getElementById('file').files[0];
        await processPDBFile(file);
      });

      // Handle example selection
      document.getElementById('examplePDB').addEventListener('change', async function(e) {
        const selection = e.target.value;
        if (!selection) return;

        try {
          const response = await fetch(`${selection}.pdb`);
          if (!response.ok) throw new Error('Failed to fetch PDB file');
          const text = await response.text();
          const file = new File([text], `${selection}.pdb`, { type: 'text/plain' });
          await processPDBFile(file);
        } catch (error) {
          console.error("Error loading example PDB:", error);
        }
      });

      function getColorForIndex(i, total) {
        const hue = (i / total) * 360;
        const h = hue / 360, s = 0.8, l = 0.5;
        let r, g, b;

        if (s === 0) {
          r = g = b = l;
        } else {
          const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1/6) return p + (q - p) * 6 * t;
            if (t < 1/2) return q;
            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
          };

          const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          const p = 2 * l - q;
          r = hue2rgb(p, q, h + 1/3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1/3);
        }
        return [r, g, b];
      }

      function drawFrame() {
        requestAnimationFrame(drawFrame);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        VM.identity()
          .perspective(3)
          .scale(0.1 * canvas.zoom, 0.1 * canvas.zoom * canvas.width/canvas.height, 0.1 * canvas.zoom)
          .move(0, 0, -20);

        prebuiltSplines.forEach((spline, i) => {
          M.S()
            .scale(10)
            .turnX(canvas.ry/100)
            .turnY(canvas.rx/100)
            .draw(spline, getColorForIndex(i, prebuiltSplines.length))
          .R();
        });
      }
      requestAnimationFrame(drawFrame);
    </script>
  </body>
</html>
